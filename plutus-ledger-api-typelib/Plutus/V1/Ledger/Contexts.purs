-- File auto generated by purescript-bridge! --
module Plutus.V1.Ledger.Contexts where

import Prelude

import ConstrIndices (class HasConstrIndices, fromConstr2Index)
import Control.Lazy (defer)
import Data.Argonaut.Core (jsonNull)
import Data.Argonaut.Decode (class DecodeJson, decodeJson)
import Data.Argonaut.Decode.Aeson ((</$\>), (</*\>), (</\>), decode, null)
import Data.Argonaut.Encode (class EncodeJson, encodeJson)
import Data.Argonaut.Encode.Aeson ((>$<), (>/\<), encode, null)
import Data.BigInt (BigInt)
import Data.Generic.Rep (class Generic)
import Data.Lens (Iso', Lens', Prism', iso, prism')
import Data.Lens.Iso.Newtype (_Newtype)
import Data.Lens.Record (prop)
import Data.Maybe (Maybe(Nothing, Just))
import Data.Newtype (class Newtype, unwrap)
import Data.Show.Generic (genericShow)
import Data.Tuple (Tuple, Tuple(Tuple))
import Data.Tuple.Nested ((/\))
import FromData (class FromData, genericFromData)
import Plutus.V1.Ledger.Credential (StakingCredential)
import Plutus.V1.Ledger.Crypto (PubKeyHash)
import Plutus.V1.Ledger.DCert (DCert)
import Plutus.V1.Ledger.Interval (Interval)
import Plutus.V1.Ledger.Scripts (Datum, DatumHash)
import Plutus.V1.Ledger.Time (POSIXTime)
import Plutus.V1.Ledger.Tx (TxOut, TxOutRef)
import Plutus.V1.Ledger.TxId (TxId)
import ToData (class ToData, genericToData)
import Type.Proxy (Proxy(Proxy))
import Types.Value (CurrencySymbol, Value)
import Data.Argonaut.Decode.Aeson as D
import Data.Argonaut.Encode.Aeson as E
import Data.Map as Map

newtype TxInfo = TxInfo
  { txInfoInputs :: Array TxInInfo
  , txInfoOutputs :: Array TxOut
  , txInfoFee :: Value
  , txInfoMint :: Value
  , txInfoDCert :: Array DCert
  , txInfoWdrl :: Array (Tuple StakingCredential BigInt)
  , txInfoValidRange :: Interval POSIXTime
  , txInfoSignatories :: Array PubKeyHash
  , txInfoData :: Array (Tuple DatumHash Datum)
  , txInfoId :: TxId
  }

instance Show TxInfo where
  show a = genericShow a

derive instance Generic TxInfo _

derive instance Newtype TxInfo _

instance HasConstrIndices TxInfo where
  constrIndices _ = fromConstr2Index [Tuple "TxInfo" 0]

instance ToData TxInfo where
  toData x = genericToData x

instance FromData TxInfo where
  fromData pd = genericFromData pd

instance EncodeJson TxInfo where
  encodeJson = defer \_ -> E.encode $ unwrap >$< (E.record
                                                   { txInfoInputs: E.value :: _ (Array TxInInfo)
                                                   , txInfoOutputs: E.value :: _ (Array TxOut)
                                                   , txInfoFee: E.value :: _ Value
                                                   , txInfoMint: E.value :: _ Value
                                                   , txInfoDCert: E.value :: _ (Array DCert)
                                                   , txInfoWdrl: E.value :: _ (Array (Tuple StakingCredential BigInt))
                                                   , txInfoValidRange: E.value :: _ (Interval POSIXTime)
                                                   , txInfoSignatories: E.value :: _ (Array PubKeyHash)
                                                   , txInfoData: E.value :: _ (Array (Tuple DatumHash Datum))
                                                   , txInfoId: E.value :: _ TxId
                                                   })

instance DecodeJson TxInfo where
  decodeJson = defer \_ -> D.decode $ (TxInfo <$> D.record "TxInfo"
      { txInfoInputs: D.value :: _ (Array TxInInfo)
      , txInfoOutputs: D.value :: _ (Array TxOut)
      , txInfoFee: D.value :: _ Value
      , txInfoMint: D.value :: _ Value
      , txInfoDCert: D.value :: _ (Array DCert)
      , txInfoWdrl: D.value :: _ (Array (Tuple StakingCredential BigInt))
      , txInfoValidRange: D.value :: _ (Interval POSIXTime)
      , txInfoSignatories: D.value :: _ (Array PubKeyHash)
      , txInfoData: D.value :: _ (Array (Tuple DatumHash Datum))
      , txInfoId: D.value :: _ TxId
      })

--------------------------------------------------------------------------------

_TxInfo :: Iso' TxInfo {txInfoInputs :: Array TxInInfo, txInfoOutputs :: Array TxOut, txInfoFee :: Value, txInfoMint :: Value, txInfoDCert :: Array DCert, txInfoWdrl :: Array (Tuple StakingCredential BigInt), txInfoValidRange :: Interval POSIXTime, txInfoSignatories :: Array PubKeyHash, txInfoData :: Array (Tuple DatumHash Datum), txInfoId :: TxId}
_TxInfo = _Newtype

--------------------------------------------------------------------------------

newtype TxInInfo = TxInInfo
  { txInInfoOutRef :: TxOutRef
  , txInInfoResolved :: TxOut
  }

instance Show TxInInfo where
  show a = genericShow a

derive instance Generic TxInInfo _

derive instance Newtype TxInInfo _

instance HasConstrIndices TxInInfo where
  constrIndices _ = fromConstr2Index [Tuple "TxInInfo" 0]

instance ToData TxInInfo where
  toData x = genericToData x

instance FromData TxInInfo where
  fromData pd = genericFromData pd

instance EncodeJson TxInInfo where
  encodeJson = defer \_ -> E.encode $ unwrap >$< (E.record
                                                   { txInInfoOutRef: E.value :: _ TxOutRef
                                                   , txInInfoResolved: E.value :: _ TxOut
                                                   })

instance DecodeJson TxInInfo where
  decodeJson = defer \_ -> D.decode $ (TxInInfo <$> D.record "TxInInfo"
      { txInInfoOutRef: D.value :: _ TxOutRef
      , txInInfoResolved: D.value :: _ TxOut
      })

--------------------------------------------------------------------------------

_TxInInfo :: Iso' TxInInfo {txInInfoOutRef :: TxOutRef, txInInfoResolved :: TxOut}
_TxInInfo = _Newtype

--------------------------------------------------------------------------------

newtype ScriptContext = ScriptContext
  { scriptContextTxInfo :: TxInfo
  , scriptContextPurpose :: ScriptPurpose
  }

instance Show ScriptContext where
  show a = genericShow a

derive instance Generic ScriptContext _

derive instance Newtype ScriptContext _

instance HasConstrIndices ScriptContext where
  constrIndices _ = fromConstr2Index [Tuple "ScriptContext" 0]

instance ToData ScriptContext where
  toData x = genericToData x

instance FromData ScriptContext where
  fromData pd = genericFromData pd

instance EncodeJson ScriptContext where
  encodeJson = defer \_ -> E.encode $ unwrap >$< (E.record
                                                   { scriptContextTxInfo: E.value :: _ TxInfo
                                                   , scriptContextPurpose: E.value :: _ ScriptPurpose
                                                   })

instance DecodeJson ScriptContext where
  decodeJson = defer \_ -> D.decode $ (ScriptContext <$> D.record "ScriptContext"
      { scriptContextTxInfo: D.value :: _ TxInfo
      , scriptContextPurpose: D.value :: _ ScriptPurpose
      })

--------------------------------------------------------------------------------

_ScriptContext :: Iso' ScriptContext {scriptContextTxInfo :: TxInfo, scriptContextPurpose :: ScriptPurpose}
_ScriptContext = _Newtype

--------------------------------------------------------------------------------

data ScriptPurpose
  = Minting CurrencySymbol
  | Spending TxOutRef
  | Rewarding StakingCredential
  | Certifying DCert

instance Show ScriptPurpose where
  show a = genericShow a

derive instance Generic ScriptPurpose _

instance HasConstrIndices ScriptPurpose where
  constrIndices _ = fromConstr2Index [Tuple "Minting" 0,Tuple "Spending" 1,Tuple "Rewarding" 2,Tuple "Certifying" 3]

instance ToData ScriptPurpose where
  toData x = genericToData x

instance FromData ScriptPurpose where
  fromData pd = genericFromData pd

instance EncodeJson ScriptPurpose where
  encodeJson = defer \_ -> case _ of
    Minting a -> E.encodeTagged "Minting" a E.value
    Spending a -> E.encodeTagged "Spending" a E.value
    Rewarding a -> E.encodeTagged "Rewarding" a E.value
    Certifying a -> E.encodeTagged "Certifying" a E.value

instance DecodeJson ScriptPurpose where
  decodeJson = defer \_ -> D.decode
    $ D.sumType "ScriptPurpose" $ Map.fromFoldable
      [ "Minting" /\ D.content (Minting <$> D.value)
      , "Spending" /\ D.content (Spending <$> D.value)
      , "Rewarding" /\ D.content (Rewarding <$> D.value)
      , "Certifying" /\ D.content (Certifying <$> D.value)
      ]

--------------------------------------------------------------------------------

_Minting :: Prism' ScriptPurpose CurrencySymbol
_Minting = prism' Minting case _ of
  (Minting a) -> Just a
  _ -> Nothing

_Spending :: Prism' ScriptPurpose TxOutRef
_Spending = prism' Spending case _ of
  (Spending a) -> Just a
  _ -> Nothing

_Rewarding :: Prism' ScriptPurpose StakingCredential
_Rewarding = prism' Rewarding case _ of
  (Rewarding a) -> Just a
  _ -> Nothing

_Certifying :: Prism' ScriptPurpose DCert
_Certifying = prism' Certifying case _ of
  (Certifying a) -> Just a
  _ -> Nothing
